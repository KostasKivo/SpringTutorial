<!DOCTYPE html>
<html lang="en" dir="ltr">

<head>
  <meta charset="utf-8">
  <title>Spring concepts </title>
  <style>
    h3>p {
      font-weight: normal;
      font-size: 17px;
    }

    .container {
      background-color: #5F9EA0;
      margin: 20px;
      padding-top: 5px;
      padding-left: 10px;
    }
  </style>
</head>

<body style="background-color: powderblue;">

  <h1>Spring concepts</h1>

  <h2>1. Inversion of Control XML config</h2>

  <div class="container">
    <h3>Inversion of Control (IoC)</h3>
    <p>The approach of outsourcing the construction and management of objects</p>
    <br><p>Creation and managing of object</p>
    <br>
  </div>

  <div class="container">
    <h3>Spring container functions</h3>
    <p>Create and manage objects (Inversion of Control)</p>
    <p>Inject object's dependencies (Dependency Injection)</p>
    <br>
  </div>

  <div class="container">
    <h3>Spring container (Application context) can be configured with 3 ways</h3>
    <p>XML config file, Java annotations, Java Source Code</p>
    <br>
  </div>

  <div class="container">
    <h3>Spring Development Process</h3>
    <p>1. Configure Spring beans <br>2. Create Spring container (known as Application context) <br>3. Retrieve Beans from Spring Container</p>
    <br>
  </div>

  <div class="container">
    <h3>What is a Spring bean</h3>
    <p>A "Spring Bean" is simply a Java object. Spring Beans are created from normal Java classes .... just like Java objects.
      <br>In the early days, there was a term called "Java Beans". Spring Beans have a similar concept but Spring Beans do not follow all of the rigorous requirements of Java Beans.
    </p>
    <br>
  </div>

  <h2>2. Dependency Injection XML config</h2>

  <div class="container">
    <h3>Dependency Injection</h3>
    <p>When we want to create an object, the Spring Object Factory does that for and and manages the dependencies</p>
    <br><p>Inject object's dependencies</p>
    <br>
  </div>

  <div class="container">
    <h3>Most common injections in Spring</h3>
    <p>Constructor injection and setter injection</p>
    <p>With the first we inject the dependencies using contrustor and with the second one using setters</p>
    <br>
  </div>

  <div class="container">
    <h3>Development process - Constructor Injection</h3>
    <p>1. Define the dependency interface and class <br> 2. Create a constructor in your class for injections <br>3. Configure the dependency injection in Spring config file</p>
    <br>
  </div>

  <div class="container">
    <h3></h3>
    <p>After we connected the dependency of the Service with our class. When Spring Object Factory
    returns the bean to us it will be fully assembled with the dependencies we made.</p>
    <br>
  </div>

  <div class="container">
    <h3>Development Process - Setter Injection</h3>
    <p>1. Create setter method in your class for injections <br> 2. Configure the dependenc injection in Spring config file</p>
    <br>
  </div>

  <div class="container">
    <h3>Development Process - Injecting literal values</h3>
    <p>1. Create setter methods in your class for uinjections <br> 2. Configure the injection in Spring config file</p>
    <br>
  </div>

  <div class="container">
    <h3>Development Process - Injecting values from properties file</h3>
    <p>1. Create properties file <br>2.Load properties file in Spring config file <br>3.Reference values from properties file</p>
    <br>
  </div>

  <h2>3. The beans lifecycle</h2>

  <div class="container">
    <h3>Scope of a bean</h3>
    <p>The default scope of a bean is Singleton. Singleton means that only one bean object will be created
      and it will be shared across all variables that may want to use it.</p>
    <br>
  </div>

  <div class="container">
    <h3>Different type of bean scopes</h3>
    <p>There are different type of bean scopes which can be declared with the scope="" configuration inside the bean xml declaration</p>
    <br>
  </div>

  <div class="container">
    <h3>Bean lifecycle Methods / Hooks </h3>
    <p>You can add custom code during bean initialization / destruction with the init-method="" and destroy-method=""</p>
    <br>
  </div>

  <div class="container">
    <h3>Development process for setting up custom Methods / Hooks</h3>
    <p>1. Define your methods for init and destroy <br> 2. Configure the method names in Spring config file</p>
    <br>
  </div>

  <div class="container">
    <h3>Lifecycle of Prototype scope</h3>
    <p>Spring does not manage the complete lifecycle of a Prototype bean as destruction callbacks are not called</p>
    <br>
  </div>

  <h2>4. Inversion of Control with Annotation config</h2>

  <div class="container">
    <h3>What are annotations?</h3>
    <p>Annotations are special labels that are added to Java classes. They provide metadata about the class.
      They are processed at compile time or run-time for special-processing</p>
    <br>
  </div>

  <div class="container">
    <h3>Scanning for Component classes</h3>
    <p>Spring will scan your Java classes for speciala nnotations. Automatically register the beans in the Spring container</p>
    <br>
  </div>

  <div class="container">
    <h3>Development process for Annotation config</h3>
    <p>1. Enable component scanning in Spring confi file <br> 2. Add the @Component annotation to your Java classes <br> 3. Retrieve bean from Spring container</p>
    <br>
  </div>

  <div class="container">
    <h3>Default bean IDs</h3>
    <p>Spring also support default bean IDs</p>
    <br>
  </div>

  <h2>5. Dependency Injection with Annotation config</h2>

  <div class="container">
    <h3>Spring autowiring</h3>
    <p>When we want to inject a dependency Spring will scan @Components and if any class does, it will inject it automatically (autowire) </p>
    <br>
  </div>

  <div class="container">
    <h3>Autowiring injection types</h3>
    <p>1. Constructor injection <br> 2. Setter Injection (or any method in general is the same) <br> 3.Field Injections</p>
    <br>
  </div>

  <div class="container">
    <h3>Development process - Constructor Injection</h3>
    <p>1. Define the dependency interface and class <br> 2. Create a constructor in your class for injections <br> 3. Configure the dependency injection with @Autowired annotation</p>
    <br>
  </div>

  <div class="container">
    <h3>Development process - Setter Injection</h3>
    <p>1. Create setter methods in class for injections <br> 2. Configure the dependecy injection with @Autowired annotation</p>
    <br>
  </div>

  <div class="container">
    <h3>Development process - Field Injection</h3>
    <p>1. Configure the dependency injection with Autowired annotation</p>
    <br>
  </div>

  <div class="container">
    <h3>Qualifier annotation</h3>
    <p>When there are a lot of beans to @Autowired and we haven't specify which one to use we get an exception.
      We solve this problem using the @Qualifier("") annotation and choosing which bean we want to use</p>
    <br>
  </div>

  <div class="container">
    <h3>Using qualifier inside constructor</h3>
    <p>Using the @Qualifier annotation inside a constructor has a different syntax than usual, so keep that in mind</p>
    <br>
  </div>

  <div class="container">
    <h3>Injecting values from properties file</h3>
    <p>We have set the properties file path inside our xml file</p>
    <br>
  </div>

  <h2>6. Bean Scopes and Lifecycle methods</h2>

  <div class="container">
    <h3>Scope of beans</h3>
    <p>By default the scope of the beans is Singleton, so a bean with Singleton scope is shared and cached in memory</p>
    <br>
  </div>

  <div class="container">
    <h3>Development process - After initialization and before destroy annotations</h3>
    <p>@PostConstruct and @PreDestroy annotation</p>
    <br>
  </div>

  <div class="container">
    <h3>Tip on prototype beans</h3>
    <p>Prototype beans are not calling the @PreDestroy annotation because the container hands them and then doesn't handle them at all. We have to destoy them manually.</p>
    <br>
  </div>

  <h2>7. Spring configuration with Java code</h2>

  <div class="container">
    <h3>Three ways of configuring Spring container</h3>
    <p>1. Full XML config <br>2. XML component scan and then use of annotations <br>3.Java code</p>
    <br>
  </div>

  <div class="container">
    <h3>Development process - Configuration with Java code</h3>
    <p>1. Create Java class and anotate @Configuration <br>2. Add component scanning support: @ComponentScan (Optional) <br>
    3. Read Spring Java configuration class <br> 4. Retrieve bean from Spring container</p>
    <br>
  </div>

  <div class="container">
    <h3>Development process - Spring beans with Java code</h3>
    <p>1. Define method to expose bean <br>2.Inject bean dependencies <br>3.Read Spring Java configuration class <br>4. Retrieve bean from Spring container</p>
    <br>
  </div>

  <div class="container">
    <h3>Define bean manually</h3>
    <p>We define the bean manually inside the Java config class with the @Bean annotation.
      The name of the method will be the bean ID</p>
    <br>
  </div>

  <div class="container">
    <h3>Development process - Read from properties file using Java</h3>
    <p>1. Create properties file <br> 2. Load properties file into Spring config <br>3.Reference values from Properties file</p>
    <br>
  </div>

  <h2>8. Spring MVC</h2>

  <div class="container">
    <h3>What is Spring MVC</h3>
    <p>It's a framework for building web application in Java based on the Model View Controller pattern. It has features of Core Spring Framework like IoC and DI</p>
    <br>
  </div>

  <div class="container">
    <h3>Components of Spring MVC application</h3>
    <p>1. A set of web pages to layout UI components <br>2. A collection of Spring beans(controllers,services,etc) <br>3. Spring configuration(XML, Annotations or Java)</p>
    <br>
  </div>

  <div class="container">
    <h3>Spring MVC Front Controller</h3>
    <p>Browser gives requests to Front Controller or DispatcherServlet which is already developed by the Spring team</p>
    <br>
  </div>

  <div class="container">
    <h3>Spring MVC flow</h3>
    <p>Browser sends information to Front Controller -> a model is sent from Front Controller to Controller and then another model is sent to View Template from Controller. Finally View Template sends information back to Web Browser
    . The model contains data the View Template is the JSP page and Controller contains the business logic ( handle the request, store/retrieve data)</p>
    <br>
  </div>

  <div class="container">
    <h3>Common view templates</h3>
    <p>Most common ones are JSP and JSTL but there are a lot more</p>
    <br>
  </div>

  <div class="container">
    <h3>WEB-INF/lib</h3>
    <p>WEB-INF/lib is a special directory, any jar files that are added there are configured manually so there is no need to configure the Build path</p>
    <br>
  </div>

  <h2>8. Creating Controllers and Views</h2>

  <div class="container">
    <h3>Development Process</h3>
    <p>1. Create Controller class <br> 2. Define Controller method <br> 3.Add Request Mapping to Controller method <br>4. Return View Name <br>5. Develop View Page</p>
    <br>
  </div>

  <div class="container">
    <h3>Spring MVC annotations</h3>
    <p>@Controller defines a Controller class and @RequestMapping("/") attaches the specified path to a method</p>
    <br>
  </div>

  <div class="container">
    <h3>Read form fields</h3>
    <p>You can read form field variables in .jsp files using ${param.} and after the dot the name of the form field you want to read</p>
    <br>
  </div>

  <div class="container">
    <h3>Spring Model</h3>
    <p>The model is a container for your application data. In your controller you can put anything in the model. View page (jsp) can access data from the model</p>
    <br>
  </div>

  <h2>9. Request Params and request Mappings</h2>

  <div class="container">
    <h3>How to bind variables</h3>
    <p>Bind variables using the @RequestParam("") Annotation. There Spring will put the request parameter</p>
    <br>
  </div>

  <div class="container">
    <h3>Parent Mapping Controller</h3>
    <p>If you @RequestMapping to Controller then all other mappings will be relative to the one on top</p>
    <br>
  </div>

  <h2>10. Spring MVC form tags and Data Binding</h2>

  <div class="container">
    <h3>Why use form tags?</h3>
    <p>Form tags will generate HTML for us and allow data binding</p>
    <br>
  </div>

  <div class="container">
    <h3>How to reference Spring MVC Form tags</h3>
    <p>Specify the Spring namespace at beginning of JSP file</p>
    <br>
  </div>

  <div class="container">
    <h3>What happens behind the scenes</h3>
    <p>In this code <br>
      <p>
        <form:form action="processForm" modelAttribute="student">
      	First name: <form:input path="firstName"/>
      	<br><br>
      	Last name: <form:input path="lastName"/>
      	<br><br>
      	<input type="submit" value="Submit"/>
      </form:form>
    </p>
      We are giving as modelAttribute the object student that we added to the model. When the form is loaded
      Spring MVC will call student.getFirstName() and student.getLastName(). When the form is submitted Spring MVC
      will call student.setFirstName() and student.setLastName() so the path attributes are the field of the object.

      <br>
       The /processForm path in the StudentController will use the @ModelAttribute("student") annotation.
  </p>
    <br>
  </div>

  <h2>11. Spring MVC form validation</h2>

  <div class="container">
    <h3>Development Process</h3>
    <p>1. Add validation rule to Customer class <br> 2. Display error messages on HTML form <br>3. Perform validation in the Controller class <br>4.Update confirmation page</p>
     <br>
  </div>

  <div class="container">
    <h3>Validation annotations</h3>
    <p>If a field requires validation we use the @NotNull so that field is not null and if it is the string inside message will be displayed.
        Also @Size(min=1,"message="") sets the minimum input for the field to one char. Finally inside the jsp file we need to add the tag form:errors and set it accordingly.
        The @Valid tag tells Spring to validate the object.
    </p>
    <br>
  </div>

  <div class="container">
    <h3>InitBinder annotation</h3>
    <p>@InitBinder will pre process all requests that come to our controller</p>
    <br>
  </div>

    <h2>12. Spring MVC validating number ranges and regular expressions</h2>

  <div class="container">
    <h3>Validation rules for int</h3>
    <p>@Min(value=5,message="Show this when error") and @Max(value=15,message="Show this when error")</p>
    <br>
  </div>

  <div class="container">
    <h3>Validation rules for regular expressions</h3>
    <p>@Pattern(regexp="",message="")</p>
    <br>
  </div>

  <h2>13. Spring Custom Validation Rule</h2>

  <div class="container">
    <h3>Development process</h3>
    <p>1. Create custom validation rule <br> 2. Add validation rule to Customer class <br> 3. Display error messages on HTML form <br>4. Update confirmation page</p>
    <br>
  </div>

  <div class="container">
    <h3>Creating the custom annotation</h3>
    <p>To create our annotation we also need a helper class which will implement ConstraintValidato</p>
    <br>
  </div>

  <h2>14. Hibernate</h2>

  <div class="container">
    <h3>What is Hibernate?</h3>
    <p>A framework for persisting/saving java objects in a database</p>
    <br>
  </div>

  <div class="container">
    <h3>Object-To-Relational Mapping (ORM)</h3>
    <p>The developer defines mapping between Java class and database table</p>
    <br>
  </div>

  <div class="container">
    <h3>Hibernate and JDBC</h3>
    <p>Hibernate uses JDBC and it's another layer of abstraction on top of the Java Database Connectivity API </p>
    <br>
  </div>

  <div class="container">
    <h3>Hibernate dev process</h3>
    <p>1. Add Hibernate Config file <br> 2. Annotate Java Class <br> 3. Develop Java Code to perform database operations</p>
    <br>
  </div>

  <div class="container">
    <h3>Hibernate Entity Class</h3>
    <p>In hibernate an entity class is a Java class that is mapped to a database table. We use annotations to map it </p>
    <br>
  </div>

  <div class="container">
    <h3>Two options for mapping the entity class</h3>
    <p>1. XML config file (legacy) <br> 2. Java Annotations(modern,preferred )</p>
    <br>
  </div>

  <div class="container">
    <h3>Key players</h3>
    <p>1. SessionFactory is a Singleton object, it reads the hibernate config file and creates session objects. <br>2.Session wraps a JDBC connection, it's used to save/retrieve objects. It is short lived and retrieved from the SessionFactory </p>
    <br>
  </div>

  <div class="container">
    <h3>How to map with Java annotations?</h3>
    <p>1. Map class to database table <br> 2. Map fields to database columns</p>
    <br>
  </div>

  <div class="container">
    <h3>Hibernate primary key</h3>
    <p>A field with the annotation of @Id will be mapped as the primary key of the table.
    With the @GeneratedValue() annotation we can select a strategy for our primary key</p>
    <br>
  </div>

  <h2>15. One-To-One Mapping Hibernate</h2>

  <div class="container">
    <h3>Annotation</h3>
    <p>@OneToOne for one to one relationship. @OneToOne(cascade="CascadeType.ALL") every CRUD action we perform on a table will perfrom
    on the other also.</p>
    <br>
  </div>

  <div class="container">
    <h3>Foreign keys</h3>
    <p>For foreign keys in Hibernate use the @JoinColumn("name="") and the name of the column that is the foreign key
    on your table.</p>
    <br>
  </div>

  <div class="container">
    <h3>@OneToOne Bi-Directional</h3>
    <p>It means that so far we have to create on object to create the other so the relationship is one way
    We want also the opposite, from the second object to be able to create the first</p>
    <br>
  </div>

  <div class="container">
    <h3>Bidirectional relationship</h3>
    <p>For the type of relationship we use @OneToOne(mappedBy="fieldNameOnOtherClass")</p>
    <br>
  </div>

  <h2>15. Many-To-One Mapping Hibernate</h2>

  <h2>16. Eager vs Lazy Loading</h2>

  <div class="container">
    <h3>Eager load</h3>
    <p>When we fetch or retrieve data on eager load we retrieve everything </p>
    <br>
  </div>

  <div class="container">
    <h3>Lazy load</h3>
    <p>When we fetch or retrieve data on eager load we retrieve on request </p>
    <br>
  </div>

  <div class="container">
    <h3>How to use</h3>
    <p>When we use a mapping annotation we use the fetch=FetchType.Lazy arguement
    Ex. @OneToMany(fetch=FetchType.Lazy)</p>
    <br>
  </div>

  <div class="container">
    <h3>Lazy loading exception</h3>
    <p>When we make a query the session must be open or else an exception will ocur.
    A workaround is to make the query while the session is open for it to be saved in memory.</p>
    <br>
  </div>

  <div class="container">
    <h3>HQL</h3>
    <p>Hibernate Query Language is a way on Hibernate to write SQL queries on Java</p>
    <br>
  </div>

  <h2>16. Many to Many relationship</h2>

  <div class="container">
    <h3>joinColumn and inverseJoinColumn</h3>
    <p>One a many to many table where it holds foreign keys of both tables, the joinColumn refers to the foreign keys of one table
    and the inverseJoinColumn refers to the foreign key of the other.</p>
    <br>
  </div>

  <div class="container">
    <h3>@JoinTable</h3>
    <p>Use @JoinTable to setup a many to many join table</p>
    <br>
  </div>

  <h2>17. Database Spring web App</h2>

  <div class="container">
    <h3>What is a servlet</h3>
    <p>Servlets are Java classes which service HTTP requests and implement the  javax.servlet.Servlet interface.</p>
    <br>
  </div>

  <div class="container">
    <h3>What is a DAO desing pattern</h3>
    <p>A Data Access object is used to separate the data persistence logic in a separate layer</p>
    <br>
  </div>

  <div class="container">
    <h3>DAO object implementation</h3>
    <p>1. Create Customer class <br> 2. Create CustomerDAO interface with the signatures of the CustomerDAO class with all the utilities <br>
       3. Create a CustomerDAOImpl class with all the utilities and implementation </p>
    <br>
  </div>

  <div class="container">
    <h3>Spring Transaction annotation</h3>
    <p>When using the @Transaction there is no need to begin and commit transaction,
      Spring will do it automatically for you.</p>
    <br>
  </div>

  <div class="container">
    <h3>Difference of Component, Controller, and Repository annotation</h3>
    <p>When we use java beans we annotate with @Component
    When we use the Spring MVC we use the @Controller
    And when we create DAO implemention we use @Repository</p>
    <br>
  </div>

  <div class="container">
    <h3>@GetMapping and @PostMapping</h3>
    <p>We use @GetMapping annotation if we want to handle ONLY GET requests
       alternately we use @PostMapping to handle ONLY POST requests</p>
    <br>
  </div>

  <div class="container">
    <h3>Service facade design pattern</h3>
    <p>When we want to apply this design pattern we use an intermediate layer for custom business logic between controller and DAO</p>
    <br>
  </div>

  <h2>18. Aspect Oriented Programming</h2>

  <div class="container">
    <h3>Code tangling</h3>
    <p>When code is tangled along with code of other functionality</p>
    <br>
  </div>

  <div class="container">
    <h3>AOP ( Aspect Oriented Programming )</h3>
    <p><a href="https://en.wikipedia.org/wiki/Aspect-oriented_programming">Wiki</a></p>
    <br>
  </div>

  <div class="container">
    <h3>AOP terminology</h3>
    <p> Aspect: module of code for a cross-cutting concern( logging, security,..) <br>
        Advice: What action is taken and when it should be applied <br>
        Join Point: When to apply code during program execution <br>
        Pointcut: A predicate expression for where advice should be applieds</p>
    <br>
  </div>

  <div class="container">
    <h3>What is weaving?</h3>
    <p>Weaving: Linking aspects with other application types or objects to
      create an advised object. In Spring weaving is performed at runtime.</p>
    <br>
  </div>

  <div class="container">
    <h3>@EnableAspectJAutoProxy what is it</h3>
    <p>This annotation enables Spring for AOP proxy support</p>
    <br>
  </div>

  <div class="container">
    <h3>Pointcut expressions Language</h3>
    <p>It's used to match which target methods to apply the advice</p>
    <br>
  </div>

  <div class="container">
    <h3>Point cut declarations</h3>
    <p>They solve the problem of a point cut expression needed to be used in multiple places and to avoid
      copy pasting it</p>
    <br>
  </div>

  <div class="container">
    <h3>Aspect order</h3>
    <p>The @Order annotation is used to define the order of the aspects</p>
    <br>
  </div>

  <div class="container">
    <h3></h3>
    <p></p>
    <br>
  </div>

  <div class="container">
    <h3></h3>
    <p></p>
    <br>
  </div>

  <div class="container">
    <h3></h3>
    <p></p>
    <br>
  </div>

  <div class="container">
    <h3></h3>
    <p></p>
    <br>
  </div>

  <div class="container">
    <h3></h3>
    <p></p>
    <br>
  </div>

  <div class="container">
    <h3></h3>
    <p></p>
    <br>
  </div>

  <div class="container">
    <h3></h3>
    <p></p>
    <br>
  </div>

  <div class="container">
    <h3></h3>
    <p></p>
    <br>
  </div>


</body>

</html>
